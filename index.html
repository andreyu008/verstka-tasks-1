<html>
<head>
	<meta charset="UTF-8">
	<meta name="andrej.veshinin" content="Domashka1">
	<title>ЯНДЕКС.ПОЧТА: КАК МЫ ИЗМЕРЯЕМ СКОРОСТЬ ЗАГРУЗКИ И УЛУЧШАЕМ ЕЁ</title>
	<body background="C:\Users\andre\Desktop\Домашка1\Ресурсы\background.jpg">

		<style>
			.tab{
			width:850px;
			height:90px;
			border:2px solid red;
			padding:10px;
			background:#f0f0f0;
			}
		</style>

		<style>
			.perenos{
			position: absolute;
			top:700pt;
			}
		</style>
<Header>
	<nav>		 
			<a href="#1">Что мы измеряем</a>
			<a href="#2">Как мы измеряем</a>
			<a href="#3">Как мы ускоряем</a>
			<a href="#4">Алгоритм Бройдена Флетчера(BFGS)</a>
			<a href="#5">Коментарии</a>
	</nav>		 
	<img src="C:\Users\andre\Desktop\Домашка1\Ресурсы\лого.png" align="right">
	<h2 align="left">Яндекс.почта: как мы измеряем скорость загрузки и улучшаем её<h2> 
</header>
	<div class="tab" style="border-radius:40px 10px;">
			Если ваш сайт медленно грузится,
			вы рискуете тем, что люди не оценят ни то,
			какой он красивый, ни то, какой он удобный.<br>
			Никому не понравится, когда все тормозит. 
			Мы регулярно добавляем в Яндекс.
			Почту новую функциональность,<br> иногда — исправляем ошибки, 
			а это значит, у нас постоянно появляются новый код
			и новая логика.<br> Всё это напрямую влияет на скорость работы интерфейса.
	</div>
<hr>
	<a name="1"></a>
	<h2><u>Что мы измеряем</u></h2>
<i>Этапы первой загрузки:</i>
	<ul><b>
		<li>Подготовка;</li>
		<li>загрузка статики (HTTP-запрос и парсинг);</li>
		<li>исполнение модулей;</li>
		<li>инициализация базовых объектов;</li>
		<li>Отрисовка.</li>  	
	</b></ul>

	<section>
	   <article>
	<h2><u>Этапы отрисовки любой страницы:</u></h2>
	  <ul><b>
         <li>подготовка к запросу на сервер;</li>
	     <li>запрос данных с сервера;</li>
	     <li>шаблонизация;</li>
	     <li>обновление DOM.</li>
         </ul>

		 <div style="position: relative; width: 200px; height: 100px" > 
    <div style="position: absolute; top: 0; left: 300; width: 200px00px"> 
        <img src='C:\Users\andre\Desktop\Домашка1\Ресурсы\rama.png' /> 
    </div> 
    
	<div style="position: absolute; top: 100%; left: 220%; width: 450px"> 
        -«Ок, теперь у нас есть метрики, мы можем отправить их на сервер» - говорим мы
		— «Что же дальше?» - вопрошаете вы
		— «А давай построим график!» - отвечаем мы
		— «А что будем считать?» - уточняете вы
    </div>
	</div> 

	<div class="perenos"> 
			Как вы знаете,<mark> медиана – это серединное
			</mark>, а не среднее значение в выборке.
		Если у нас имеются числа 1, 2, 2, 3, 8, 10, 20, то медиана – 3, а среднее – 6,5.
		В общем случае медиана отлично показывает, сколько грузится средний пользователь.

		В случае ускорения или замедления медиана, конечно, изменится. Но она не может
		рассказать, сколько пользователей ускорилось, а сколько замедлилось.

		APDEX – метрика, которая сразу говорит: хорошо или плохо. Метрика
		работает очень просто. Мы выбираем временной интервал [0; t], такой, что если
		время показа страницы попало в него, то пользователь счастлив. Берем еще один
		интервал, (t; 4t] (в четыре раза больше первого), и считаем, что если страница
		показана за это время, то пользователь в целом удовлетворен скоростью работы,
		но уже не настолько счастлив. И применяем формулу:

		<mark>(кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех)</mark>.
		Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
		хорошо или плохо работает почта.</p>
	</div>
	
	<style>
			body {
				background: url("Ресурсы/background.jpg");
			}
			figure{
				background:#F0F0F0;
				padding:10px;
				border:4px solid blue;
				width:950px;
			}
		</style>
	</head>

<a name="2"></a>		
<hgroup>
	<h1 align="center">Как мы измеряем</h1>
	<h2>Сейчас модуль обновления сам логирует все свои стадии, и можно легко понять
		причину замедления: медленнее стал отвечать сервер либо слишком долго
		выполняется JavaScript.</h2></hgroup>

<figure>
<figcaption>Выглядит это примерно так:</figcaption>
	<pre><code>
		this.timings['look-ma-im-start'] = Date.now();
		this.timings['look-ma-finish'] = Date.now();
	</code>
	</pre>		   
</figure>
<p></p>
<p>C помощью <code>Date.now()</code> мы получаем текущее время. Все тайминги собираются и при
отправке рассчитываются. </p>
<figure>
<figcaption>На этапах разница между “end” и “start” не считается,
			а все вычисления производятся в конце:</figcaption>
	<pre><code>
		var totalTime = this.timings['look-ma-finish'] - this.timings['look-ma-im-start'];</code>
	</pre>
<p></p>
	<figcaption>И на сервер прилетают подобные записи:</figcaption>
	<pre><code>serverResponse=50&domUpdate=60</code>
	</pre>
</figure>
<hr>
<a name="3"></a>
<hgroup>
<h2 align="center">Как мы ускоряем</h2>
<h3>Чтобы снизить время загрузки почты при выходе новых версий,
мы уже делаем следующее:</h3>
	<b><ul>
		<li>включаем gzip;</li>
		<li>выставляем заголовки кэширования;</li>
		<li>фризим CSS, JS, шаблоны и картинки;</li>
		<li>используем CDN;</li>
	</ul></b>
</hgroup>
<p>Мы подумали: <blockquote>«А что если хранить где-то старую версию файлов, а при выходе новой
передавать только <mark>diff</mark> между ней и той, которая сохранена у пользователя?»</blockquote>
В браузере же останется просто наложить патч на клиенте.

На самое деле эта идея не новая.<br> Уже существуют стандарты для HTTP — например,
RFC 3229 «Delta encoding in HTTP» и «Google SDHC», — но по разным причинам они
не получили должного распространения в браузерах и на серверах.

Мы же решили сделать свой аналог на JS. Чтобы реализовать этот метод обновления,
начали искать реализации diff на JS. На популярных хостингах кода нашли
библиотеки:</p>
	<b><ul>
		<li>VCDiff;</li>
		<li>google-diff-patch-match.</li>	
	</ul></b>
<h4>Для окончательного выбора библиотеки нам нужно сравнить:</h4>
	<table border="1" bgcolor="white" align="center" height="100" width="250">
		<thead>
			<tr>
			  <th>Библиотека</th>
			  <th>IE 9 </th>
			  <th>Opera 12</th>
			</tr>
		</thead>
		<tbody>
			<tr>
			   <td>vcdiff</td>
			   <td>8</td>
			   <td>5</td>
			</tr>   
			<tr>
				<td>google diff</td>
				<td>1363</td>
				<td>76</td>		
			</tr>
		</tbody>
	</table>
<h5>После того как мы определились с библиотекой для диффа, нужно определиться с тем,
	где и как хранить статику на клиенте.</h5>
<figure>
	<figcaption>Формат файла с патчами для проекта выглядит так:</figcaption>
		<pre><code>
				{
					"k": "jane.css",
					"p": [patch],
					"s": 4554
				},
				{
					"k": "jane.css",
					"p": [patch],
					"s": 4554
				}
		</code></pre>
</figure>
<p>То есть это обычный массив из объектов. Каждый объект — отдельный ресурс. У
	каждого объекта есть три свойства: <blockquote>k — названия ключа в <code>localStorage</code> 
	для этого ресурса.</blockquote> <blockquote>p — патч для ресурса, который сгенерировал vcdiff.
	</blockquote> <blockquote>s — чексумма для ресурса актуальной версии, чтобы потом можно было проверить 
	правильность наложения патча на клиенте.</blockquote>
</p>
<h5 align="center"><u>Чексумма</u> вычисляется по алгоритму Флетчера.</h5>
<a name="4"></a>
<dl>
    <b><dt alt="BFGS">Алгоритм Бройдена Флетчера(BFGS)</dt></b>
		<i><dd>итерационный метод численной оптимизации, предназначенный для
нахождения локального максимума/минимума нелинейного функционала
без ограничений.
		</dd></i>
</dl>
<u><p>Почему именно алгоритм Флетчера, а не другие популярные алгоритмы вроде:</p></u>
<dl>
    <strong>
		<dt>CRC16/32 -</dt></strong>
			<i><dd>алгоритм нахождения контрольной суммы, предназначенный для проверки
					целостности данных.</dd></i>
    <strong>
		<dt>md5 -</dt></strong>
        <i><dd>128-битный алгоритм хеширования. Предназначен для создания «отпечатков»
				или дайджестов сообщения произвольной длины и последующей проверки
				их подлинности.</dd></i>
</dl>  
<h5 align="center">Потому что он быстрый, компактный и легок в реализации!!!</h5>
<hr>
<hgroup>
	<h5>Итог.</h5>
	<h6>Фактически мы экономим 80-90% трафика. Размер загружаемой статитки в байтах:</h6>
</hgroup>
	<table align="center" border="1" bgcolor="white" height="100" width="250" >
	   <thead>
	      <tr>
		     <th>Релиз</th>
			 <th>С патчем</th>
			 <th>Без патча</th>
		  </tr>
	   </thead>
	      <tr>
	         <td>7.7.20</td>
			 <td>397</td>
			 <td>174 549</td>
		  </tr>
		  <tr>
		     <td>7.7.21</td>
			 <td>383</td>
			 <td>53 995</td>
		  </tr>
		  <tr>
		      <td>7.7.22</td>
			  <td>483</td>
			  <td>3 995</td>
		  </tr>
	</table>
<hr>
<footer>
	<p align="right">Автор: <strong>@doochik</strong>
		С++ разработчик
	<address align="right">Электронная почта:<a href="mailto:doochik@yandex-team.ru"> (doochik@yandex-team.ru)</a></address>
</p>
<p align="right">Компания: Яндекс</p>
</footer>
<a name="5"></a>
<p>Коментарии(3):</p>
<section>
	<article>
		- Mogaika <a href="mailto:mogaika@yandex-team.ru">(mogaika@yandex-team.ru)</a> <time datetime=>30 ноября 2014 в 17:05</time>

		  А можете привести сравнение, на сколько быстрее грузится lite версия?
	</article>
	<article>
		- JIguse <a href="mailto:mrawesome@yandex.ru">(mrawesome@yandex.ru)</a> 29 ноября 2014 в 21:30

		  Спасибо за статью, познавательно. Здорово, что Яндекс делится некоторыми
		  подробностями о внутренней работе сервисов.
	</article>
	<article>
		- Brister <a href="mailto:brist89@yandex-team.ru">(brist89@yandex-team.ru)</a> 24 ноября 2014 в 13:13

		  (кол-во счастливых пользователей + кол-во удовлетворенных / 2) / (кол-во всех).
		  Получается значение от нуля до единицы, которое, видимо, лучше всего показывает,
		  хорошо или плохо работает почта.

		  наверное все-таки от 0.5 до 1
	</article>
	<article>
		- alexeimois <a href="mailto:test@yandex.ru">(test@yandex.ru)</a> 22 ноября 2014 в 17:35

		  Мы измеряем скорость загрузки с помощью Яндекс.Метрики:
		  help.yandex.ru/metrika/reports/monitoring_timing.xml
	</article>
</section>
<p></p>
<hr>
<footer>
	<p align="right">© Яндекс, <a href="mailto:help@yandex.ru">help@yandex.ru</a>, Хохрякова, 10</p>
	
</footer>
</body>
</head>
</html>